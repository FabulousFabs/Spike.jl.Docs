var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Spike allows quick and easy implementations of spiking network models through a lot of flexibility offered by the way it utilises meta-programming for designing models - fortunately, it is also really quite easy to use. The following is a brief introduction.","category":"page"},{"location":"guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Spike is not currently available as a released package, but may be installed using the Julia package manager. From your Julia REPL, type ] to enter the Pkg mode and run","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"  pkg> add https://github.com/FabulousFabs/Spike.jl.git","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"That's it!","category":"page"},{"location":"guide/#Magic-models","page":"Guide","title":"Magic models","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Generally speaking, all Spike models boil down to three fundamental components: Models that contain and track all specifications, NeuronGroups and Synapses where the former contains a collection of neurons governed by the same equations, whereas the latter is much the same but for synapses between NeuronGroups.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"To make things a bit easier, we generally don't have to specify Model structures ourselves. Instead, we can cast_magic() and let Spike figure out the rest behind the scenes for us. Once we have cast magic, we can specify structures and connections in our main file.","category":"page"},{"location":"guide/#Adding-neurons","page":"Guide","title":"Adding neurons","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"For starters, let us create some neurons, then:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using Spike;\n\n# Casting magic ensures that the back-end will put together a model structure for us.\ncast_magic();\n\n# Next, let's actually specify some neurons\npopulation = NeuronGroup(N = 10, method = euler, events = Dict(),\n                         eq = :(dv_dt = (.-(v - E_L) .+ I) ./ 𝜏_v;\n                                I_t = 3e-3 .* rand(N) ./ dt;),\n                         parameters = Dict(:v => zeros(10),\n                                           :v_th => ones(10),\n                                           :v_reset => -0.1 * ones(10),\n                                           :E_L => zeros(10),\n                                           :I => zeros(10),\n                                           :𝜏_v => 100e-3 * ones(10)));","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, the most pertinent part here is the specification of a set of equations that will govern the behaviour of these neurons. We specified these equations as an expression and, as we see through the use of rand(N), we can also use regular Julia functions in them if need be. Similarly, however, we also need to obey to Julia's way of writing maths. For example, all parameters (e.g., v, E_L, ...) are vectors and, as such, we need to use dot notation .-, .+, .*, ./ in our equations, too. More on expressions and how to phrase your equations later.","category":"page"},{"location":"guide/#Running-a-magic-model","page":"Guide","title":"Running a magic model","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"For now, we have 10 neurons in our group who receive random input current. Let's simulate this population and see what some of the currents and voltages look like. To do this, we will use a StateMonitor and run where, given that we do not supply a Model structure, run will build a magic network from our scope for us. Like so:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"...\n\n# Let's add a monitor that measures v and I\nstate_monitor = Spike.StateMonitor(obj = population, vars = [:v, :I]);\n\n# Let's do a magic run\nSpike.run(; T = 1.0, dt = 1e-3);\n\n# ...and plot the results for our neurons\nusing Plots;\nplot(repeat(state_monitor.t, outer = [1, 10]), transpose(state_monitor.states[:I]))\nplot(repeat(state_monitor.t, outer = [1, 10]), transpose(state_monitor.states[:v]))\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Nice, that was pretty easy! Okay, so the input is all over the place, as we expected. But wait, what's going on with the membrane potential? Why isn't it being reset but keeps on rising?","category":"page"},{"location":"guide/#Adding-events","page":"Guide","title":"Adding events","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Well, it turns out that we specified events = Dict() for our neurons. We can create arbitrary events that will govern some conditional behaviour of our neurons. Note that, importantly, events are also always broadcast to synapses. More on this later. For the time being, let us go back to our neuron group and add some events to our call, like so:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"...\n\n# let's change the definition of our neuron group\npopulation = NeuronGroup(N = 10, method = euler,\n                         eq = :(dv_dt = (.-(v - E_L) .+ I) ./ 𝜏_v;\n                                I_t = 3e-3 .* rand(N) ./ dt;),\n                         events = Dict(:spike => (:(v .> v_th), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(10),\n                                           :v_th => ones(10),\n                                           :v_reset => -0.1 * ones(10),\n                                           :E_L => zeros(10),\n                                           :I => zeros(10),\n                                           :𝜏_v => 100e-3 * ones(10)));\n\n...\n\n# let's also use an event monitor to track spikes directly\nspike_monitor = EventMonitor(obj = population, event = :spike);\n\n...\n\n# and let's also plot them\nscatter(spike_monitor.t, spike_monitor.i, markershape = :vline)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"That's more like it, we have quite some spiking behaviour now. Very nice!","category":"page"},{"location":"guide/#Adding-synapses","page":"Guide","title":"Adding synapses","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, let's move on and create a slightly more complex model where groups of neurons actually communicate with each other. To do this, let us change our population such that its input currents are no longer random but simply decay in time. This means adjusting","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"population = NeuronGroup(N = 100, method = euler,\n                         eq = :(dv_dt = (.-(v - E_L) .+ I) ./ 𝜏_v;\n                                dI_dt = .-I ./ 𝜏_I;),\n                         events = Dict(:spike => (:(v .> v_th), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(100),\n                                           :v_th => ones(100),\n                                           :v_reset => -0.1 * ones(100),\n                                           :E_L => zeros(100),\n                                           :I => zeros(100),\n                                           :𝜏_v => 50e-3 * ones(100),\n                                           :𝜏_I => 10e-3 * ones(100)));\npop_states = StateMonitor(obj = population, vars = [:v, :I]);\npop_spikes = EventMonitor(obj = population, event = :spike);","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Excellent. Notice that we also increased the population size and adjusted some parameters to make it more interesting. Next, let's create a second population that we will use as a random spiking population, like so:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"rd_spikers = NeuronGroup(N = 100, method = euler,\n                         eq = :(v_t = rand(N);),\n                         events = Dict(:spike => (:(v .> p), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(100),\n                                           :v_reset => zeros(100),\n                                           :p => 0.975 * ones(100)));\nrds_spikes = EventMonitor(obj = rd_spikers, event = :spike);","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"And now, let's create some Synapses like so:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"forward = Synapses(pre = rd_spikers, post = population,\n                   cond = :((i .- 25) .<= j .&& (i .+ 25) .>= j),\n                   prob = 0.25,\n                   on_pre = Dict(:spike => :(post_I = post_I .+ w;)),\n                   parameters = Dict(:w => rand));","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, there are a few important things to take note of here:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We are using an expression, again, as a condition for creating synapses that, effectively, amounts to a kernel of size 50.\nOn top of that, we are asking that synapses be created with a probability of .25 only, effectively yielding 12-13 synapses per neuron.\nWe are now using the event :spike that we created earlier and are using on_pre to create a conditional equation. In this equation, we have full access to all parameters of the synapse, the pre- and the postsynaptic neuron by using no prefix, pre_* or post_*, respectively. Note that on_post is also available.\nWe are specifying parameters for the synapse, but we are using a new syntax that is not vectorised that applies only to synapses. Parameters can either be of type Number or Function.\nIf we wanted to, we could also specify eq and method for these synapses, just like we did for neurons.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"For completeness sake, here is the full example so far:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using Spike;\nusing Plots;\n\n# Casting magic ensures that the back-end will put together a model structure for us.\ncast_magic();\n\n# Let's create some random spikers\nrd_spikers = NeuronGroup(N = 100, method = euler,\n                         eq = :(v_t = rand(N);),\n                         events = Dict(:spike => (:(v .> p), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(100),\n                                           :v_reset => zeros(100),\n                                           :p => 0.975 * ones(100)));\n\n# Let's create our target population\npopulation = NeuronGroup(N = 100, method = euler,\n                         eq = :(dv_dt = (.-(v - E_L) .+ I) ./ 𝜏_v;\n                                dI_dt = .-I ./ 𝜏_I;),\n                         events = Dict(:spike => (:(v .> v_th), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(100),\n                                           :v_th => ones(100),\n                                           :v_reset => -0.1 * ones(100),\n                                           :E_L => zeros(100),\n                                           :I => zeros(100),\n                                           :𝜏_v => 50e-3 * ones(100),\n                                           :𝜏_I => 10e-3 * ones(100)));\n\n# And let's add some synapses\nforward = Synapses(pre = rd_spikers, post = population,\n                   cond = :((i .- 25) .<= j .&& (i .+ 25) .>= j),\n                   prob = 0.25,\n                   on_pre = Dict(:spike => :(post_I = post_I .+ w;)),\n                   parameters = Dict(:w => rand));\n\n# Let's add a monitor that measures v and I\npop_states = StateMonitor(obj = population, vars = [:v, :I]);\npop_spikes = EventMonitor(obj = population, event = :spike);\nrds_spikes = EventMonitor(obj = rd_spikers, event = :spike);\n\n# Let's do a magic run\nSpike.run(; T = 1.0, dt = 1e-3);\n\n# ...and plot the results for our neurons\nplot(repeat(pop_states.t, outer = [1, 10]), transpose(pop_states.states[:I]))\nplot(repeat(pop_states.t, outer = [1, 10]), transpose(pop_states.states[:v]))\nscatter(rds_spikes.t, rds_spikes.i, markershape = :vline)\nscatter(pop_spikes.t, pop_spikes.i, markershape = :vline)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Before we move on, feel free to toy with this example a little bit to familiarise yourself with these basic functions.","category":"page"},{"location":"guide/#On-expressions","page":"Guide","title":"On expressions","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"There are a couple more rules to follow when writing expressions that have not been mentioned yet and should now be mentioned (perhaps you have even discovered some of them while playing around with the model above).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Expressions can have one of four forms:\ndifferential equations: dx_dt = .- x ./ 𝜏;\nlinear equations: x_t = rand(N) .* y;\nassignment: x = x_r;\nconditional: x .== y\nSubexpressions should always be terminated with a semicolon.\nCurrently, only eq::Expr parameters (i.e., in NeuronGroup and Synapses) support differential equations. Hooks, like on_pre, for example, do not.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"With that in mind, let's move to the final section of this introduction.","category":"page"},{"location":"guide/#Adding-operations","page":"Guide","title":"Adding operations","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Finally, let's bring it all together. Say we want to have some kind of time-varying input to our model that we simulated otherwise (for example, we are simulating an agent's decision in an environment). To do this, we will need to be able to run our model in parallel to our simulation. We can do this by using an Operation. Take the following model, for example:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using Spike;\nusing Plots;\n\n# Casting magic ensures that the back-end will put together a model structure for us. # hide\ncast_magic();\n\n# Let's create our target population\nN_pop = 100\npopulation = NeuronGroup(N = N_pop, method = euler,\n                         eq = :(dv_dt = (.-(v - E_L) .+ I) ./ 𝜏_v;\n                                dI_dt = .-I ./ 𝜏_I;),\n                         events = Dict(:spike => (:(v .> v_th), :(v = v_reset;))),\n                         parameters = Dict(:v => zeros(N_pop),\n                                           :v_th => ones(N_pop),\n                                           :v_reset => -0.1 * ones(N_pop),\n                                           :E_L => zeros(N_pop),\n                                           :I => zeros(N_pop),\n                                           :𝜏_v => 50e-3 * ones(N_pop),\n                                           :𝜏_I => 10e-3 * ones(N_pop)));\n\n# Let's capture spikes\npop_spikes = EventMonitor(obj = population, event = :spike);\n\n# An arbitrary function\nfunction my_function()\n       # here's where I can do something else, at the same clock speed as the model\n       # and then feed something back into the model.\n       # for example:\n       global population;\n       population.parameters[:I] .= 5 .* rand(population.N);\nend\n\n# register the operation\ncallback = Operation(op = my_function);\n\n# Run everything\nSpike.run(; T = 1.0, dt = 1e-3);\n\n# ...and plot the results for our neurons\nscatter(pop_spikes.t, pop_spikes.i, markershape = :vline)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, we can easily simulate the model and, for example, an agent in an environment whose actions the model determines at the same time.","category":"page"},{"location":"guide/#Advanced-usage","page":"Guide","title":"Advanced usage","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"For more information, refer to the Examples or Library.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = Spike","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Spike]\nPages   = [\"Spike.jl\", \"Model.jl\", \"Neurons.jl\", \"Synapses.jl\", \"Operations.jl\", \"Monitors.jl\", \"Magic.jl\", \"Expressions.jl\", \"Build.jl\", \"Solvers.jl\"]\nOrder   = [:module, :type, :function, :constant, :macro]","category":"page"},{"location":"library/#Spike.Model","page":"Library","title":"Spike.Model","text":"Model\n\nMain structure for creating a model. Note that, for convenience, this structure does not have to be created yourself. If you can provide adequate scope and have called cast_magic to start the scope, run will magically  created the model for you (and return it after simulation).\n\nINPUTS:\n    Neurons::Dict{Symbol, NeuronGroup}          -   All neuron groups in the model. (default = Dict())\n    Synapses::Dict{Symbol, Synapses}            -   All synapse groups in the model. (default = Dict())\n    Operations::Dict{Symbol, Operation}         -   All operations in the model. (default = Dict())\n    StateMonitors::Dict{Symbol, StateMonitor}   -   All state monitors in the model. (default = Dict())\n    EventMonitors::Dict{Symbol, EventMonitor}   -   All event monitors in the model. (default = Dict())\n    verbose::Bool                               -   Verbose updates? (default = true)\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.run-Tuple{Model}","page":"Library","title":"Spike.run","text":"run(model::Model; T::Float64, \n                  dt::Float64 = 1e-3)::Model\n\nMain entry point for simulations.\n\nINPUTS:\n    model::Model    -   The model to run.\n    T::Float64      -   Total time to run the model for.\n    dt::Float64     -   Time step size. (default = 1e-3)\n\nOUTPUTS:\n    model::Model    -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.run-Tuple{}","page":"Library","title":"Spike.run","text":"run(; T::Float64, \n      dt::Float64 = 1e-3, \n      magic_obj::DataType = SpikeObject, \n      magic_tar::Module = Main, \n      verbose::Bool = true)::Model\n\nEntry point for magic networks. Creates the model and yields it to the simulation entry point.\n\nINPUTS:\n    T::Float64              -   Total time to run the model for.\n    dt::Float64             -   Time step size.\n    magic_obj::DataType     -   DataType that identifies magic objects. (default = SpikeObject)\n    magic_tar::Module       -   Module where magic is utilised. (default = Main)\n    verbose::Bool           -   Verbose updates? (default = true)\n\nOUTPUTS:\n    model::Model            -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.status-Tuple{Model, String}","page":"Library","title":"Spike.status","text":"status(model::Model,\n       status::String,\n       e::String = \"\\n\")\n\nLogging function at runtime.\n\nINPUTS:\n    model::Model        -   The model object.\n    status::String      -   The status.\n    e::String           -   End-of-line characters.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.NeuronGroup","page":"Library","title":"Spike.NeuronGroup","text":"NeuronGroup <: SpikeObject\n\nMain structure for creating neurons. Note that, for convenience, you can often simply use one of the auxiliary functions provided in this file (e.g., LIF) rather than rewriting expressions yourself (unless that is explicitly required).\n\nINPUTS:\n    N::Int                                          -   Number of neurons in group\n    eq::Expr                                        -   Equation determining the behaviour of neurons in this group.\n    method::Function                                -   Function to use for solving differential equations. See Spike::Solvers.\n    parameters::Dict{Symbol, Any}                   -   All parameters for all neurons.\n    events::Dict{Symbol, Tuple{Expr, Expr}}         -   Event specifications in the form of events = Dict(:name => (:(condition), :(effect;))).\n    __built::Bool                                   -   (Internal) Has this model been built? (default = false)\n    __normeqs::Dict{Symbol, Expr}                   -   (Internal) Built equations. (default = Dict())\n    __diffeqs::Dict{Symbol, Expr}                   -   (Internal) Built differential equations. (default = Dict())\n    __eventeqs::Dict{Symbol, Dict{Symbol, Expr}}    -   (Internal) Built event equations. (defualt = Dict())\n    __eventlog::Dict{Symbol, Vector{Bool}}          -   (Internal) Events at runtime. (default = Dict())\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.LIF-Tuple{}","page":"Library","title":"Spike.LIF","text":"LIF(; N::Int = 1, \n      normalised::Bool = false)::NeuronGroup\n\nShorthand to create standard Leaky Integrate-and-Fire neurons.\n\nINPUTS:\n    N::Int                  -   Number of neurons (default = 1)\n    normalised::Bool        -   Should values be normalised rather than biological (i.e., spanning [0, 1])? (default = false)\n\nOUTPUTS:\n    neurons::NeuronGroup    -   LIF-group of neurons\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.step-Tuple{NeuronGroup}","page":"Library","title":"Spike.step","text":"step(neurons::NeuronGroup; dt::Float64,\n                           t::Float64)::NeuronGroup\n\nPerforms one time step for all the equations specified for a NeuronGroup. Note that this includes both state updates as well as event checks and logging.\n\nINPUTS:\n    neuron::NeuronGroup     -   NeuronGroup to perform a step on.\n    dt::Float64             -   Time step size.\n    t::Float64              -   Current time.\n\nOUTPUTS:\n    neuron::NeuronGroup     -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.Synapses","page":"Library","title":"Spike.Synapses","text":"Synapses <: SpikeObject\n\nMain structure for creating synapses between NeuronGroups. Note that both cond::Expr and prob::Float64 may be used complemantarily (or left as is to default to full connections).\n\nINPUTS:\n    pre::NeuronGroup                                -   Presynaptic neuron group.\n    post::NeuronGroup                               -   Postsynaptic neuron group.\n    cond::Expr                                      -   Conditional expression for building connectivity matrix. (default = :())\n    prob::Float64                                   -   Probability of realising a potential entry in connectivity matrix. (default = 1.0)\n    eq::Expr                                        -   Equation determining the behaviour of the synapses.\n    method::Function                                -   Function to use for solving differential equations. See Spike::Solvers.\n    parameters::Dict{Symbol, Any}                   -   Parameter pre-specifications; either func where func(N) is valid or ::Number.\n    on_pre::Dict{Symbol, Expr}                      -   Hooks into presynaptic events and their effects (e.g., Dict(:spike => :(post_I = post_I .+ w;))).\n    on_post::Dict{Symbol, Expr}                     -   Hooks into postsynaptic events and their effects (e.g., Dict(:spike => :(pre_f_t_f = t;))).\n    __built::Bool                                   -   (Internal) Have these synapses been built? (default = false)\n    __parameters::Dict{Symbol, Any}                 -   (Internal) Full parameters after building model. (default = Dict())\n    __normeqs::Dict{Symbol, Expr}                   -   (Internal) Built equations. (default = Dict())\n    __diffeqs::Dict{Symbol, Expr}                   -   (Internal) Built differential equations. (default = Dict())\n    __preeqs::Dict{Symbol, Dict{Symbol, Expr}}      -   (Internal) Built presynaptic event equations. (default = Dict())\n    __posteqs::Dict{Symbol, Dict{Symbol, Expr}}     -   (Internal) Built postsynaptic event equations. (default = Dict())\n    __M_pre::Vector{Vector{Int}}                    -   (Internal) Built forwards connectivity matrix. (default = Dict())\n    __M_post::Vector{Vector{Int}}                   -   (Internal) Built backwards connectivity matrix. (default = Dict())\n    __N::Int                                        -   (Internal) Built number of synapses.\n    __i::Vector{Int}                                -   (Internal) Built i-th index of every synapse, indicating presynaptic neuron.\n    __j::Vector{Int}                                -   (Internal) Built j-th index of every synapse, indicating postsynaptic neuron.\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.step-Tuple{Synapses}","page":"Library","title":"Spike.step","text":"step(synapses::Synapses; dt::Float64,\n                         t::Float64)::Synapses\n\nPerforms one time step for all equations specified for a group of synapses. Note that this also includes state updates as well as event hooks and effects.\n\nINPUTS:\n    synapses::Synapses      -   Synapses to perform step on.\n    dt::Float64             -   Time step size.\n    t::Float64              -   Current time.\n\nOUTPUTS:\n    synapses::Synapses      -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.Operation","page":"Library","title":"Spike.Operation","text":"Operation <: SpikeObject\n\nWrapper structure for custom operations to be run during simulation.\n\nINPUTS:\n    op::Function        -   External function to be called.\n    every::Float64      -   Delay between calls. (default = 1e-3)\n    cycle::String       -   Timing within cycle. (default = \"pre\")\n    __built::Bool       -   (Internal) Has this operation been built? (default = false)\n    __last::Float64     -   (Internal) Last operation. (default = -Inf)\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.step-Tuple{Operation}","page":"Library","title":"Spike.step","text":"step(operation::Operation; dt::Float64, \n                           t::Float64, \n                           cycle::String)::Operation\n\nPerforms one time step of an operation. This is an internal function and should not be called manually.\n\nINPUTS:\n    operation::Operation    -   Operation to perform time step on.\n    dt::Float64             -   Time step size.\n    t::Float64              -   Current time.\n    cycle::String           -   Current cycle.\n\nOUTPUTS:\n    operation::Operation    -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.EventMonitor","page":"Library","title":"Spike.EventMonitor","text":"EventMonitor <: SpikeObject\n\nMain structure for monitoring events.\n\nINPUTS:\n    obj::NeuronGroup                    -   Object to be monitored.\n    event::Symbol                       -   Event to be tracked. (default = :spike)\n    t::Vector{Float64}                  -   (Internal) Time vector. (default = Float64[])\n    i::Vector{Int}                      -   (Internal) State vectors. (default = Int[])\n    __built::Bool                       -   (Internal) Has this monitor been built? (default = false)\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.StateMonitor","page":"Library","title":"Spike.StateMonitor","text":"StateMonitor <: SpikeObject\n\nMain structure for monitoring states of neurons or synapses.\n\nINPUTS:\n    obj::Any                                    -   Object to be monitored.\n    vars::Vector{Symbol}                        -   Parameters to be monitored in object.\n    every::Float64                              -   Delay between calls. (default = 1e-3)\n    t::Vector{Float64}                          -   (Internal) Time vector. (default = Float64[])\n    states::Dict{Symbol, Array{Float64, 2}}     -   (Internal) State vectors. (default = Dict())\n    __built::Bool                               -   (Internal) Has this monitor been built? (default = false)\n    __last::Float64                             -   (Internal) Last check. (default = -Inf)\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.step-Tuple{EventMonitor}","page":"Library","title":"Spike.step","text":"step(monitor::EventMonitor; dt::Float64,\n                            t::Float64)::EventMonitor\n\nPerforms one time step of the monitor. This is an internal fuction and should not be called manually.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.step-Tuple{StateMonitor}","page":"Library","title":"Spike.step","text":"step(monitor::StateMonitor; dt::Float64, \n                            t::Float64)::StateMonitor\n\nPerforms one time step of the monitor. This is an internal function and should not be called manually.\n\nINPUTS:\n    monitor::StateMonitor   -   StateMonitor to perform time step on.\n    dt::Float64             -   Time step size.\n    t::Float64              -   Current time.\n\nOUTPUTS:\n    monitor::StateMonitor   -   Self\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.SpikeObject","page":"Library","title":"Spike.SpikeObject","text":"SpikeObject\n\nAbstract type definition that enables look-up and matching of magic objects.\n\n\n\n\n\n","category":"type"},{"location":"library/#Spike.cast_magic-Tuple{}","page":"Library","title":"Spike.cast_magic","text":"cast_magic()\n\nEnables creation of a magic network that will be built from the module's global scope. This should always be called when trying to utilise magic networks.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.collect_magic_objects-Tuple{}","page":"Library","title":"Spike.collect_magic_objects","text":"collect_magic_objects(; magic_obj::DataType = SpikeObject, \n                        magic_tar::Module = Main)::Vector{Symbol}\n\nCollects all magic objects from the module. This is an internal function and should not be called manually.\n\nINPUTS:\n    magic_obj::DataType     -   DataType that identifies magic objects. (default = SpikeObject)\n    magic_tar::Module       -   Module where magic is utilised. (default = Main)\n\nOUTPUTS:\n    cols::Vector{Symbol}    -   Vector of symbols of magic objects in module.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.create_magic_model-Tuple{}","page":"Library","title":"Spike.create_magic_model","text":"create_magic_model(; magic_obj::DataType = SpikeObject, \n                     magic_tar::Module = Main)::Model\n\nCreates a model from all available magic objects that have corresponding vectorised forms in the standard model structure. This is an internal function and should not be called manually.\n\nINPUTS:\n    magic_obj::DataType     -   DataType that identifies magic objects. (default = SpikeObject)\n    magic_tar::Module       -   Module where magic is utilised. (default = Main)\n\nOUTPUTS:\n    model::Model            -   The magic network.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.__cast_magic","page":"Library","title":"Spike.__cast_magic","text":"__cast_magic::Bool\n\nInternal variable to keep track of whether or not magic has been cast. Do not change this manually. Please use cast_magic instead.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Spike.categorise_subexpressions-Tuple{Expr}","page":"Library","title":"Spike.categorise_subexpressions","text":"categorise_subexpressions(expr::Expr)::Tuple{Dict{Symbol, Expr}, Dict{Symbol, Expr}}\n\nTakes a set of equations formulated as an expression and categorises by whether or not they need to be differentiated at runtime. Currently, all equations are implicitly interpreted with respect to time. Typical syntax of equations should be:\n\n:(I_t = A ./ 2 .+ A ./ 2 .* sin(2 * π * t);\n  dv_dt = (.-(v .- v_rest) .+ I) ./ 𝜏;\n  A = rand(N);)\n\nwhich would create a regular function I(t), a differential equation dv/dt and an assignment of A for the model at runtime.\n\nINPUTS:\n    expr::Expr                                                              -   Expression to evaluate\n\nOUTPUTS:\n    (eqs_norm, eqs_diff)::Tuple{Dict{Symbol, Expr}, Dict{Symbol, Expr}}     -   Tuple of normal and differential equations.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.interpolate_from_dict-Tuple{Expr, Dict{Symbol, Any}}","page":"Library","title":"Spike.interpolate_from_dict","text":"interpolate_from_dict(expr::Expr, \n                      dict::Dict{Symbol, Any})::Any\n\nSet of functions to allow for data to be supplied easily for evaluating expressions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.__regex_subexpression_eq_assi","page":"Library","title":"Spike.__regex_subexpression_eq_assi","text":"__regex_subexpression_eq_assi\n\nRegular expression that defines the syntax of assignments in categorise_subexpressions. This is an internal variable and should not be changed.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Spike.__regex_subexpression_eq_diff","page":"Library","title":"Spike.__regex_subexpression_eq_diff","text":"__regex_subexpression_eq_diff\n\nRegular expression that defines the syntax of differential equations in categorise_subexpressions. This is an internal variable and should not be changed.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Spike.__regex_subexpression_eq_norm","page":"Library","title":"Spike.__regex_subexpression_eq_norm","text":"__regex_subexpression_eq_norm\n\nRegular expression that defines the syntax of normal equations in categorise_subexpressions. This is an internal variable and should not be changed.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Spike.build-Tuple{EventMonitor}","page":"Library","title":"Spike.build","text":"build(target::EventMonitor)::EventMonitor\n\nBuilds an event monitor into the model that will be updated as events occur. This is an internal function and should not be called manually.\n\nINPUTS:\n    target::EventMonitor    -   EventMonitor to build.\n\nOUTPUTS:\n    target::EventMonitor    -   Built monitor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.build-Tuple{NeuronGroup}","page":"Library","title":"Spike.build","text":"build(target::NeuronGroup)::NeuronGroup\n\nBuilds a group of neurons such that their expressions may be evaluated more directly. Also performs safety checks. This is an internal functino and should not be called manually.\n\nINPUTS:\n    target::NeuronGroup     -   Group of neurons to build.\n\nOUTPUTS:\n    target::NeuronGroup     -   Built group of neurons.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.build-Tuple{Operation}","page":"Library","title":"Spike.build","text":"build(target::Operation)::Operation\n\nBuilds an operation into the model, which will be executed at prespecified intervals. This is an internal function and should not be called manually.\n\nINPUTS:\n    target::Operation       -   Operation to build.\n\nOUTPUTS:\n    target::Operation       -   Built operation.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.build-Tuple{StateMonitor}","page":"Library","title":"Spike.build","text":"build(target::StateMonitor)::StateMonitor\n\nBuilds a state monitor into the model that will be updated periodically. This is an internal function and should not be called manually.\n\nINPUTS:\n    target::StateMonitor    -   StateMonitor to build.\n\nOUTPUTS:\n    target::StateMonitor    -   Built monitor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.build-Tuple{Synapses}","page":"Library","title":"Spike.build","text":"build(target::Synapses)::Synapses\n\nBuilds synapses between two groups of neurons such that their equations can be evaluated more directly. Also performs safety checks and handles evaluation of connectivity matrices as well as internal parametrisation. This is an internal function and should not be called manually.\n\nINPUTS:\n    target::Synapses    -   Synapses to build.\n\nOUTPUTS:\n    target::Synapses    -   Built group of synapses.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.euler-Tuple{}","page":"Library","title":"Spike.euler","text":"euler(; sym::Symbol, \n        eq::Expr, \n        par::Dict{Symbol, Any}, \n        dt::Float64, \n        t::Float64)::Any\n\nEuler's method for differential equations.\n\nINPUTS:\n    sym::Symbol                 -   Symbol of the parameters to be differentiated.\n    eq::Expr                    -   Expression of the differential equation.\n    par::Dict{Symbol, Any}      -   Paramters for the differential equation.\n    dt::Float64                 -   Step size.\n    t::Float64                  -   Time at step zero.\n\nOUTPUTS:\n    phi_n_plus_1::Any           -   Approximate value at step one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.heun-Tuple{}","page":"Library","title":"Spike.heun","text":"heun(; sym::Symbol, \n       eq::Expr, \n       par::Dict{Symbol, Any}, \n       dt::Float64, \n       t::Float64)::Any\n\nHeun's method for differential equations.\n\nINPUTS:\n    sym::Symbol                 -   Symbol of the parameters to be differentiated.\n    eq::Expr                    -   Expression of the differential equation.\n    par::Dict{Symbol, Any}      -   Paramters for the differential equation.\n    dt::Float64                 -   Step size.\n    t::Float64                  -   Time at step zero.\n\nOUTPUTS:\n    phi_n_plus_1::Any           -   Approximate value at step one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Spike.rk2-Tuple{}","page":"Library","title":"Spike.rk2","text":"rk2(; sym::Symbol, \n      eq::Expr, \n      par::Dict{Symbol, Any}, \n      dt::Float64, \n      t::Float64)::Any\n\nSecond order Runge-Kutta time stepper for differential equations.\n\nINPUTS:\n    sym::Symbol                 -   Symbol of the parameters to be differentiated.\n    eq::Expr                    -   Expression of the differential equation.\n    par::Dict{Symbol, Any}      -   Paramters for the differential equation.\n    dt::Float64                 -   Step size.\n    t::Float64                  -   Time at step zero.\n\nOUTPUTS:\n    phi_n_plus_1::Any           -   Approximate value at step one.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"#Spike.jl","page":"Home","title":"Spike.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A spiking neural network simulator for Julia.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Write flexible spiking network models\nUse expressions to implement equations and relations directly\nLight-weight and easy-to-use","category":"page"},{"location":"#How-to-get-started?","page":"Home","title":"How to get started?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For pointers on getting started, please consult the Guide.","category":"page"},{"location":"#How-to-go-beyond-that?","page":"Home","title":"How to go beyond that?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a full breakdown of the package, please consult the Library.","category":"page"}]
}
